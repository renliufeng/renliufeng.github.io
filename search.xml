<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[next-update-to-7]]></title>
    <url>%2F2019%2F06%2F11%2Fnext-update-to-7%2F</url>
    <content type="text"><![CDATA[下载 Next 6 主题，解压缩并重命名为next6，放置于 \themes\ 目录下，这样保留旧版本的 next 主题，可以随时切换回去。修改站点配置文件 _config.yml，指定使用新主题 ExtensionsPlugins: https://hexo.io/plugins/Themes: https://hexo.io/themes/theme: next61 23 4修改主题语言设置 #language: zh-Hans # next 5.xlanguage: zh-CN # next 61 2修改主题配置文件\themes\next6_config.yml，比较旧版本主题配置文件_config.yml中改动的地方，一一修改到新版本中。旧版本主题个性化定制的文件复制到新版本主题对应目录下:next/source/css/_custom/* next/source/css/_variables/* next/layout/_custom/* 执行命令: hexo clean # 清理旧文件hexo d -g # 重新编译/发布]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo-head-picture-rotate]]></title>
    <url>%2F2019%2F06%2F06%2Fhexo-head-picture-rotate%2F</url>
    <content type="text"><![CDATA[Hexo Next主题将头像显示成圆形，鼠标放上去有旋转效果。将头像显示成圆形，鼠标放上去有旋转效果。找到/themes/next/source/css/_common/components/sidebar/sidebar-author.styl替换其中的site-author-img和site-author-image:hover属性 头像显示圆形123456789101112131415.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: site-author-image-border-color; /* start*/ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */&#125; 头像旋转事件123456789/* start */.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(1.1); moz-transform: rotate(360deg) scale(1.1); ms-transform: rotate(360deg) scale(1.1); transform: rotate(360deg) scale(1.1);&#125;/* end */]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ddd-change-in-trade]]></title>
    <url>%2F2018%2F10%2F30%2Fddd-change-in-trade%2F</url>
    <content type="text"><![CDATA[互联网行业追求“快速迭代”，在整个过程中，用户的需求总是善变的，那系统领域中又有哪些是不变与易变的呢。针对到店综合多种行业各种不同的交易流程进行分析，我们基本可以归纳出：领域源于需求，但高于需求。相对于善变的用户需求而言，领域知识和领域模型本身是相对“静止”的，是“不变”的，会随着需求逐步演进。 问题与挑战（1）到综行业多，同一种类型的业务差异也很大 到综涉及结婚、丽人、亲子、休娱等10+大小BU，几十种行业，不同的行业有不同的玩法。即使是同一种预订业务，对于每种行业预订的商品、预订流程、结算流程，都有差异。比如ktv行业重时间包房管理，酒吧预订关注与订座位，体验课关注课程的时间预订。 （2）业务交易形态多样化 不同的业务交易形态开始产生，比如丽人医美行业客单量大，项目重决策，团购就不太适合，衍生出线上预付定金，到店付尾款的模式。另外丽人美甲、足疗按摩等行业用户层面更愿意带客，所以从团购衍生出拼团的业务形态。另外还有买单的场景， 不同的业务形态，发货的时间点、方式，核销的时间点、结算的逻辑都有差异。 （3）需要支持的平台能力丰富 交易流程整个环节中，需要对接各样的通用平台能力，例如点评-美团订单中心，客服系统、UGC评价。这么多业务，业务总会有一些定制化需求，如何能够统一快速支持，是一个挑战。 核心思路与解法需求是千变万化的，不同的业务，不同的流程，如何能够稳定快速地支撑业务的需求是关键，主要考虑从以下两方面来进行。首先梳理出业务中的不变量，定下整体的领域模型与框架，再考虑通过配置化、开放定制化等能力去支撑业务定制化的需求。 梳理业务中的不变量针对第一个问题，项目初期，我们计划搭建一套通用的预订交易流程系统，但是虽然是预订业务，每个BU都会有差异。所以我们针对已有的定制开发的KTV预订和足疗预订去做了分析和总结，判断整个预订行业中有哪些是可以抽象出通用能力的。首先我们基于现有的部分需求，整理出每个BU的预订流程图，最后发现对于预订而言，整个流程是相似的，较大的差异性主要在于预订的商品和接单的流程。基于此会发现订单、商品、购买接单、核销、结算这几个大模块都是通用的。整个需要提供较多定制能力的模块主要在于商品模型与接单的模型。确定好方向之后，我们再对于子领域进行更细粒度的分析，在接单模型中，我们将接单规则配置和业务逻辑拆分。接单的逻辑可能会变，但接单领域模型里接单的规则配置确是可以固定不变的。在通用预订的交易流程系统基本完善之后，我们面临着第二个问题，越来越多的业务形态开始出现。以拼团为例，在预订交易流程的基础上，我们发现整体的交易流程的模型都一样可以支持，有较大差异点仅在于购买流程上。针对于拼团，需要整个拼团拼团成功，才会真正发券。后续的核销、结算流程都是一样的，针对这些不变的领域，仅需要对业务进行扩充，就可以支持。在支持多种交易形态的过程中，我们发现已有的对接的一些平台能力，例如客服、评价、诚信等，都会有些差异。都可以采取一样的思路，先抽象出不变的部分，再针对有变化的部分通过配置化等方式支持特殊的定制。 快速支撑不断变化的需求（1）不同业务需要支持的不同场景 模型扩展：拼团等新业务刚出现的时候，原先模型可能无法支持的话，首先会从复用的角度去考虑对模型进行扩展。原先只支持到订单一个层级，抽象出父订单的模型-拼团，一个父订单下面会关联多个子订单。后续类似购物车等形态，都是可以通过此模型进行支持。 服务扩展：一些预订业务或新业务可能涉及到第三方对接的库存发货管理，我们通过新增服务的方式，将预订的流程开放出去，给到第三方接入的能力。这一块相对独立，支持定制，且不影响主流程。 （2）多样的平台能力的需求，如何稳定快速支持接入的需求 每一个新业务接入或者新的交易产生，对于用户中心订单列表、客服订单列表的展示和操作都有些定制需求，用户商户侧的评价也有展示的区别。主要思路：模块服务独立，不影响核心流程。单独子模块，再针对不同的业务提供定制化或者配置化的能力。 具体方案及拆解整体技术架构解决方案的思路都是从领域与微服务化的思路去考虑，如何能够很好地去分析领域模型和服务拆分，我们主要会从下面几个方向着手。 （1）梳理业务流程中通用流程节点 在切分微服务之前，我们要做的第一件事情就是梳理业务流程。不妨找业务领域的专家咨询，通过与他们沟通从而了解真实的业务流程，并将其绘制成流程图。对于过于复杂的业务流程，我们也可单独绘制流程图，并增加相关的流程说明。当然也能提供相应的状态图，用于说明业务流程中所涉及状态的变化过程。花再多时间去分析业务流程都不过分，现在所花的每一分钟都是相当值得的。产品需求是多变的，但是对于交易流程而言，整体的领域模型基本是确定的。我们从目前互联网常见的一些业务着手分析：团购、拼团、预订、电商、外卖、猫眼等。梳理完每块业务的整体流程后，我们整理下。 业务形态 发货模式 货物模型 核销方式 结算方式 团购 库存为主 团购券 到店验证 券核销后结算 拼团 拼团成功后扣库存 消费码 到店验证 消费码核销后结算 预订 库存/商家接单/第三方对接 消费码 到店验证 消费码核销后结算 电商/外卖 库存/商家接单 货物 用户收到货确认 订单核销后结算 猫眼 库存/商家接单 消费码/实体票 到店验证/收到货确认 订单核销后结算 通过整个交易流程的分析，大概抽象出来都是下面这个流程，每一个模块会有类似，也有差异。 （2）梳理出系统各种聚合功能模块 我们可以对系统的功能进行一个发散的整理，最终明确整个系统的核心“用户”。比如交易流程，核心“用户”就是订单，整套系统都是围绕着订单在走。（3）归纳整理出业务的整体框架 基于上面的分析，我们可以整理出整块交易流程业务的整体框架。 （4）抽取公共服务（不变） 一般服务拆分首先考虑横向拆分。按照不同的业务领域进行拆分，例如订单、商品、消费码、结算等，形成独立的业务领域微服务集群。其次，要做好微服务的分层：梳理和抽取核心应用、公共应用，作为独立的服务下沉到核心和公共能力层，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。在业务流程中与业务不太相关的部分，我们可考虑将其剥离出来，并形成公共服务。例如，价格服务、库存管理服务、销量服务其他第三方接口等。一般情况下，抽取的公共服务都不太会经常变化，所以“一个月内是否会有频繁改动”这也是我们抽取公共服务的一个判断标准。我们一定要想办法将不变的东西从可变的世界中抽取出来。每种公共服务都对应一个微服务，每个微服务都有相关API，方便其他服务调用。目前公司推动的服务化就是在完善这方面的基础建设。（5）定义业务服务（易变） 当公共服务抽取完毕后，业务流程中剩下来的部分就是业务服务了。建议刚开始实施项目的时候，不需要将业务服务的边界切得太细，可以考虑先“大切几块”，但需要确保每个服务之间尽量不要有依赖关系。换句话说，每个服务都是独立的，虽然此时服务的块头可能比较大。目前交易侧主要分了几块比较大的服务，后面针对丰富的需求可以再逐渐不断扩张。我们先确保这些大块头服务可以运行在微服务基础设施上，再不断将它们进行细化，拆解为更小的服务。结果及收益总结多变的业务中，我们会发现核心流程基本不变，分支流程与业务逻辑是易变的。针对于核心流程，如果有些需要品类与产品形态支持定制的，尽量通过配置化思路去解决。 而对于一些易变的流程或页面，可以分模块拆分出来，控制每个模块的影响范围，做到不涉及核心流程。 效果目前交易流程已经支持了预订、点单、扫码付、一口价、拼团等多种业务形态，接入大小业务30+，日订单量10W，涉及到综所有BU。通过对通用逻辑的抽象，目前交易流程新增业务1~2人周支持开发与联调即可。 能够在复用通用能力的同时，支持业务的定制能力。 未来的方向目前领域模型的划分还是相对较粗，业务订单和统一订单的分工职责需要明确。应用架构上，会针对不断变化的交易形态，拆分出更多业务逻辑层的服务出来。同时，后续也会提供越来越多的交易有关的平台能力提供给业务侧去使用。 针对业务复杂变化较大的发货服务领域，会做更细的拆分，把其中接单、第三方对接等等抽象出公用的基础服务，在上层支持丰富的业务定逻辑。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ddd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域资源共享 CORS 简介]]></title>
    <url>%2F2018%2F06%2F06%2Fcros-introduce%2F</url>
    <content type="text"><![CDATA[CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。本文详细介绍CORS的内部机制。CORS官方解释 简介CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求。（1) 请求方法是以下三种方法之一： 123HEADGETPOST （2）HTTP的头信息不超出以下几种字段： 12345AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。浏览器对这两种请求的处理，是不一样的。 简单请求基本流程对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。 123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。 （1）Access-Control-Allow-Origin该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。 withCredentials 属性上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。 Access-Control-Allow-Credentials: true另一方面，开发者必须在AJAX请求中打开withCredentials属性。 var xhr = new XMLHttpRequest();xhr.withCredentials = true;否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。 但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。 xhr.withCredentials = false;需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 非简单请求预检请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 下面是一段浏览器的JavaScript脚本。 12345var url = 'http://api.alice.com/cors';var xhr = new XMLHttpRequest();xhr.open('PUT', url, true);xhr.setRequestHeader('X-Custom-Header', 'value');xhr.send(); 上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。 12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。（1）Access-Control-Request-Method该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。（2）Access-Control-Request-Headers该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 预检请求的回应服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 Access-Control-Allow-Origin: * 如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。 XMLHttpRequest cannot load http://api.alice.com. Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.服务器回应的其他CORS相关字段如下。 1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 （2）Access-Control-Allow-Headers如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 （3）Access-Control-Allow-Credentials该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 浏览器的正常请求和回应一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 下面是”预检”请求之后，浏览器的正常CORS请求。 1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的。 下面是服务器正常的回应。 12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。 与JSONP的比较CORS与JSONP的使用目的相同，但是比JSONP更强大。 JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客中如何插入图片]]></title>
    <url>%2F2017%2F06%2F06%2Fhexo-insert-picture%2F</url>
    <content type="text"><![CDATA[在网上查了一下有以下几种方式往hexo文章中插入图片 ## 本地引用 绝对路径当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。对于source/images/image.jpg这张图片可以用以下语法访问到 1![](/images/image.jpg) 图片既可以在首页内容中访问到，也可以在文章正文中访问到。 相对路径图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置博客根目录下的_config.yml来生成。 1post_asset_folder: true 将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。_posts/post_name/image.jpg这张照片可以用以下方式访问： 1![](image.jpg) 上述markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。如果希望图片在文章和首页中同时显示，可以使用标签插件语法。_posts/post_name/image.jpg这张照片可以用以下方式访问： CDN引用除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。因国内访问github速度较慢，所以将突破放到国内图床上，然后引用外链是常用的方法。常用图床总结：https://sspai.com/post/40499 图床，也就是专门提供存储图片的地方，我们只要通过图床提供的 API 接口，把图片上传上去，就可以通过外链访问了，根本不用操心图片是怎么存的，硬盘空间不够了，硬盘坏了，访问速度比较慢等等问题，这些图床都会帮我们搞定，他们会用各种技术帮我们做图片相关的优化和服务，比如多机互备、CDN 加速、图片处理、图片鉴黄、文本识别等等。当然，图床也是有缺点的，当所有人都把图片存在同一个图床上，万一有一天图床真挂了，那所有图片就都无法访问了，虽然这种情况的概率很低，但并不等于不会发生目前图床可以分为两种，一种是公共图床，一种是自建图床。公共图床也就是利用公共服务的图片上传接口，来提供图片外链的服务，比如新浪微博。自建图床，也就是利用各大云服务商提供的存储空间或者自己在 VPS 上使用开源软件来搭建图床，存储图片，生成外链提供访问，比如七牛、Lychee 开源自建图床方案。 微博图床（Chrome浏览器有个“新浪微博图床”插件，可以自动生成markdown链接）简单方便七牛：需要注册且实名认证等太麻烦，放弃腾讯云等云存储服务，需要先将照片放到云盘，然后找到超链接，然后粘贴到文章。太麻烦，放弃。【强烈推荐！！！】ipic 工具，具体用法请谷歌，支持监控剪贴板，一键上传到微博图床，免费版默认是微博图床，支持七牛云等，下载地址: https://itunes.apple.com/cn/app/id1101244278?mt=12 使用GitHub存储博客图片创建一个空的repo然后将图片push到repo中点击图片进去，有个download，右键复制链接将链接插入文章 1![logo](https://github.com/xxxx/xx.jpg)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven 依赖管理的最佳实践]]></title>
    <url>%2F2017%2F05%2F27%2Fmaven-perfect-practice%2F</url>
    <content type="text"><![CDATA[一般一个父pom项目下面常常有好几个子pom项目模块，而且几个子模块依赖的很多jar包，比如groupId/artifactid/version都是相同的，这样有三个弊端：(1) 造成jar包重复依赖(2) 造成版本号重复依赖(3) 升级某个版本号时，要修改好几个子模块 一、在父模块中定义全部dependencies 在父模块中配置dependencies，那样所有子模块都自动继承。 例如在父pom文件中定义好我们需要的全部jar： Java代码 收藏代码 junit junit 4.8.2 test log4j log4j 1.2.16 这样子模块只要继承父模块就能直接使用这些jar包，不仅达到了依赖一致的目的，还省掉了大段代码。 然而：这么做是有些不妥的地方，例如某个子模块，比如A不需要父模块log4j的依赖，但也直接继承了，造成了jar包臃肿，多余依赖。 二、在父模块中定义全部dependencyManagement 我们需要一种在父模块中定义好全部的jar包依赖，而子模块需要哪一种指定哪一种，这样既做到了集中式配置，又做到了子模块需要什么配置什么的灵活性。 而dependencyManagement就可以做到。针对这个问题我们可以使用继承机制以及dependencyManagement元素就能解决这个问题。 dependencyManagement只会影响现有依赖的配置，但不会引入依赖。 例如我们可以在父模块中配置如下： Java代码 收藏代码 junit junit 4.8.2 test log4j log4j 1.2.16 这段配置不会给任何子模块引入依赖，但如果某个子模块需要使用JUnit和Log4j的时候，我们就可以简化依赖配置成这样： Java代码 收藏代码 junit junit log4j log4j 不要的模块，就不需要引入，而dependencyManagement完美的做到了这点。 现在只需要groupId和artifactId，其它元素如version和scope都能通过继承父POM的dependencyManagement得到，如果有依赖配置了exclusions，那节省的代码就更加可观。 但重点不在这，重点在于现在能够保证所有模块使用的JUnit和Log4j依赖配置是一致的。而且子模块仍然可以按需引入依赖， 如果我不配置log4j dependency，父模块中dependencyManagement下的log4j依赖不会对子模块产生任何影响。 然而，如果在父模块中引入了大量的jar包依赖，这个父模块的dependencyManagement就会包含大量的依赖，如果你想把这些依赖分类以更清晰的管理，那就不可能了。 三、使用import单独出dependencyManagement此时为了应对父模块中引入了大量的jar包依赖造成父模块臃肿，我们需要一种可以把dependencyManagement放到外面去分开管理，这样很清晰很多，才能更好的管理更多的jar。 而import scope依赖能解决这个问题。 我们可以把dependencyManagement放到单独的专门用来管理依赖的POM中，然后在需要使用依赖的模块中通过import scope依赖，就可以引入dependencyManagement。 1、我们可以写这样一个用于依赖管理的子模块POM： Java代码 收藏代码 4.0.0 wang.conge.demo sample-dependency-infrastructure pom 1.0-SNAPSHOT junit junit 4.8.2 test log4j log4j 1.2.16 2、然后我们的父模块只需要通过非继承的方式来引入这段依赖管理配置： Java代码 收藏代码 wang.conge.demo sample-dependency-infrastructure 1.0-SNAPSHOT pom import 3、最后我们的子模块需要哪个jar包就引入哪个jar包 Java代码 收藏代码 junit junit log4j log4j 完美，有没有？ 这样，父模块的POM就会非常简洁，由专门的子模块为pom的POM来管理依赖，也契合的面向对象设计中的单一职责原则。 此外，我们还能够创建多个这样的依赖管理POM，以更细化的方式管理依赖。这种做法与面向对象设计中使用组合而非继承也有点相似的味道。 事实上spring-boot非常的简洁已用，也是使用import的方式来管理那么多的jar包依赖的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java项目搭建中的开源组件]]></title>
    <url>%2F2017%2F05%2F24%2Fjava-project-open-source%2F</url>
    <content type="text"><![CDATA[想从零开始搭建一个Java Web的项目，并上线，需要涉及到多方面的框架与组件。利用一些开源的组件和工具可以让效率更高，性能更好，可用性更高。现在将搭建过程中用到的开源项目列出来，已作备忘。 ##核心工具代码仓库：]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目交接说明]]></title>
    <url>%2F2016%2F06%2F13%2Fproject-transfer-guide%2F</url>
    <content type="text"><![CDATA[交接内容项目git、数据库、作业、页面、权限交接时间点需求设计等文档case情况 交接关键点1.确认交接时间范围，交接完成之前需求、case均由前团队负责，交接之后需求、Case由新团队负责。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache HttpClient 使用备忘]]></title>
    <url>%2F2015%2F12%2F23%2Fapache-httpclient-guide%2F</url>
    <content type="text"><![CDATA[HttpClient是Apache Jakarta Common下的子项目，用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包，并且它支持HTTP协议最新的版本和建议。HttpClient相比传统JDK自带的URLConnection，增加了易用性和灵活性，它不仅使客户端发送Http请求变得容易，而且也方便了开发人员测试接口（基于Http协议的），既提高了开发的效率，也方便提高代码的健壮性。 版本依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.1&lt;/version&gt;&lt;/dependency&gt; 特性 基于标准、纯净的java语言。实现了Http1.0和Http1.1 以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE）。 支持HTTPS协议。 通过Http代理建立透明的连接。 利用CONNECT方法通过Http代理建立隧道的https连接。 Basic, Digest, NTLMv1, NTLMv2, NTLM2 Session, SNPNEGO/Kerberos认证方案。 插件式的自定义认证方案。 便携可靠的套接字工厂使它更容易的使用第三方解决方案。 连接管理器支持多线程应用。支持设置最大连接数，同时支持设置每个主机的最大连接数，发现并关闭过期的连接。 自动处理Set-Cookie中的Cookie。 插件式的自定义Cookie策略。 Request的输出流可以避免流中内容直接缓冲到socket服务器。 Response的输入流可以有效的从socket服务器直接读取相应内容。 在http1.0和http1.1中利用KeepAlive保持持久连接。 直接获取服务器发送的response code和 headers。 设置连接超时的能力。 实验性的支持http1.1 response caching。 源代码基于Apache License 可免费获取。 使用方法使用HttpClient发送请求、接收响应很简单，一般需要如下几步即可。 创建HttpClient对象。 创建请求方法的实例，并指定请求URL。如果需要发送GET请求，创建HttpGet对象；如果需要发送POST请求，创建HttpPost对象。 如果需要发送请求参数，可调用HttpGet、HttpPost共同的setParams(HetpParams params)方法来添加请求参数；对于HttpPost对象而言，也可调用setEntity(HttpEntity entity)方法来设置请求参数。 调用HttpClient对象的execute(HttpUriRequest request)发送请求，该方法返回一个HttpResponse。 调用HttpResponse的getAllHeaders()、getHeaders(String name)等方法可获取服务器的响应头；调用HttpResponse的getEntity()方法可获取HttpEntity对象，该对象包装了服务器的响应内容。程序可通过该对象获取服务器的响应内容。 释放连接。无论执行方法是否成功，都必须释放连接 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275package com.test;import org.apache.http.HttpEntity;import org.apache.http.ParseException;import org.apache.http.client.ClientProtocolException;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.conn.ssl.SSLConnectionSocketFactory;import org.apache.http.conn.ssl.SSLContexts;import org.apache.http.conn.ssl.TrustSelfSignedStrategy;import org.apache.http.entity.ContentType;import org.apache.http.entity.mime.MultipartEntityBuilder;import org.apache.http.entity.mime.content.FileBody;import org.apache.http.entity.mime.content.StringBody;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;import org.junit.Test;import javax.net.ssl.SSLContext;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.security.KeyManagementException;import java.security.KeyStore;import java.security.KeyStoreException;import java.security.NoSuchAlgorithmException;import java.security.cert.CertificateException;import java.util.ArrayList;import java.util.List;public class HttpClientTest &#123; @Test public void jUnitTest() &#123; get(); &#125; /** * HttpClient连接SSL */ public void ssl() &#123; CloseableHttpClient httpclient = null; try &#123; KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType()); FileInputStream instream = new FileInputStream(new File("d:\\tomcat.keystore")); try &#123; // 加载keyStore d:\\tomcat.keystore trustStore.load(instream, "123456".toCharArray()); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; instream.close(); &#125; catch (Exception ignore) &#123; &#125; &#125; // 相信自己的CA和所有自签名的证书 SSLContext sslcontext = SSLContexts.custom().loadTrustMaterial(trustStore, new TrustSelfSignedStrategy()).build(); // 只允许使用TLSv1协议 SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext, new String[]&#123;"TLSv1"&#125;, null, SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER); httpclient = HttpClients.custom().setSSLSocketFactory(sslsf).build(); // 创建http请求(get方式) HttpGet httpget = new HttpGet("https://localhost:8443/myDemo/Ajax/serivceJ.action"); System.out.println("executing request" + httpget.getRequestLine()); CloseableHttpResponse response = httpclient.execute(httpget); try &#123; HttpEntity entity = response.getEntity(); System.out.println("----------------------------------------"); System.out.println(response.getStatusLine()); if (entity != null) &#123; System.out.println("Response content length: " + entity.getContentLength()); System.out.println(EntityUtils.toString(entity)); EntityUtils.consume(entity); &#125; &#125; finally &#123; response.close(); &#125; &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; finally &#123; if (httpclient != null) &#123; try &#123; httpclient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * post方式提交表单（模拟用户登录请求） */ public void postForm() &#123; // 创建默认的httpClient实例. CloseableHttpClient httpclient = HttpClients.createDefault(); // 创建httppost HttpPost httppost = new HttpPost("http://localhost:8080/myDemo/Ajax/serivceJ.action"); // 创建参数队列 List&lt;namevaluepair&gt; formparams = new ArrayList&lt;namevaluepair&gt;(); formparams.add(new BasicNameValuePair("username", "admin")); formparams.add(new BasicNameValuePair("password", "123456")); UrlEncodedFormEntity uefEntity; try &#123; uefEntity = new UrlEncodedFormEntity(formparams, "UTF-8"); httppost.setEntity(uefEntity); System.out.println("executing request " + httppost.getURI()); CloseableHttpResponse response = httpclient.execute(httppost); try &#123; HttpEntity entity = response.getEntity(); if (entity != null) &#123; System.out.println("--------------------------------------"); System.out.println("Response content: " + EntityUtils.toString(entity, "UTF-8")); System.out.println("--------------------------------------"); &#125; &#125; finally &#123; response.close(); &#125; &#125; catch (ClientProtocolException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e1) &#123; e1.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭连接,释放资源 try &#123; httpclient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 发送 post请求访问本地应用并根据传递参数不同返回不同结果 */ public void post() &#123; // 创建默认的httpClient实例. CloseableHttpClient httpclient = HttpClients.createDefault(); // 创建httppost HttpPost httppost = new HttpPost("http://localhost:8080/myDemo/Ajax/serivceJ.action"); // 创建参数队列 List&lt;namevaluepair&gt; formparams = new ArrayList&lt;namevaluepair&gt;(); formparams.add(new BasicNameValuePair("type", "house")); UrlEncodedFormEntity uefEntity; try &#123; uefEntity = new UrlEncodedFormEntity(formparams, "UTF-8"); httppost.setEntity(uefEntity); System.out.println("executing request " + httppost.getURI()); CloseableHttpResponse response = httpclient.execute(httppost); try &#123; HttpEntity entity = response.getEntity(); if (entity != null) &#123; System.out.println("--------------------------------------"); System.out.println("Response content: " + EntityUtils.toString(entity, "UTF-8")); System.out.println("--------------------------------------"); &#125; &#125; finally &#123; response.close(); &#125; &#125; catch (ClientProtocolException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e1) &#123; e1.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭连接,释放资源 try &#123; httpclient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 发送 get请求 */ public void get() &#123; CloseableHttpClient httpclient = HttpClients.createDefault(); try &#123; // 创建httpget. HttpGet httpget = new HttpGet("http://www.baidu.com/"); System.out.println("executing request " + httpget.getURI()); // 执行get请求. CloseableHttpResponse response = httpclient.execute(httpget); try &#123; // 获取响应实体 HttpEntity entity = response.getEntity(); System.out.println("--------------------------------------"); // 打印响应状态 System.out.println(response.getStatusLine()); if (entity != null) &#123; // 打印响应内容长度 System.out.println("Response content length: " + entity.getContentLength()); // 打印响应内容 System.out.println("Response content: " + EntityUtils.toString(entity)); &#125; System.out.println("------------------------------------"); &#125; finally &#123; response.close(); &#125; &#125; catch (ClientProtocolException e) &#123; e.printStackTrace(); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭连接,释放资源 try &#123; httpclient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 上传文件 */ public void upload() &#123; CloseableHttpClient httpclient = HttpClients.createDefault(); try &#123; HttpPost httppost = new HttpPost("http://localhost:8080/myDemo/Ajax/serivceFile.action"); FileBody bin = new FileBody(new File("F:\\image\\sendpix0.jpg")); StringBody comment = new StringBody("A binary file of some kind", ContentType.TEXT_PLAIN); HttpEntity reqEntity = MultipartEntityBuilder.create().addPart("bin", bin).addPart("comment", comment).build(); httppost.setEntity(reqEntity); System.out.println("executing request " + httppost.getRequestLine()); CloseableHttpResponse response = httpclient.execute(httppost); try &#123; System.out.println("----------------------------------------"); System.out.println(response.getStatusLine()); HttpEntity resEntity = response.getEntity(); if (resEntity != null) &#123; System.out.println("Response content length: " + resEntity.getContentLength()); &#125; EntityUtils.consume(resEntity); &#125; finally &#123; response.close(); &#125; &#125; catch (ClientProtocolException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; httpclient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>HttpClient</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记之程序员修炼之道(The Pragmatic Programmer)]]></title>
    <url>%2F2015%2F12%2F02%2Freading-the-pragmatic-programmer%2F</url>
    <content type="text"><![CDATA[《程序员修炼之道》由一系列的独立的部分组成，涵盖的主题从个人责任、职业发展，直到用于使代码保持灵活、并且易于改编和复用的各种架构技术。利用许多富有娱乐性的奇闻轶事、有思想性的例子以及有趣的类比，全面阐释了软件开发的许多不同方面的最佳实践和重大陷阱。无论你是初学者，是有经验的程序员，还是软件项目经理，本书都适合你阅读。 –豆瓣 注重实效的思想基础 破窗效应 经营自己的知识资产（定期、多元化、管理分享、低买高卖、重新评估和平衡） 目标设定 每年至少学习一种新语言 每季度阅读一本技术书籍 也要阅读非技术书籍 上课 参加本地用户组织 试验不同的编程环境 跟上潮流 上网 如何交流 注重实效的途径 DRY-Don’t Repeat Yourself 正交性（消除无关事物之间的影响） 可撤销性（不存在最终决策）-代码“摇滚” 用曳光弹找到目标-直观、快速、可重复 用户及早看到能工作的东西（及时反馈） 开发者构建了一个他们能在其中工作的结构（便于团队开发） 有一个集成平台（小批量集成） 投资方可以看到有可演示的东西 工作进展会更加清晰明朗 原型与便签 有效的工具 纯文本的威力 Shell GUI所见及所得与所见即全部所得 用好一种编辑器 源码控制 调试 不要假定，要证明 代码生成器 Write Code That Writes Code 编码习惯 避免靠巧合编程，深思熟虑地去编程 估算算法速率 早重构，常重构（肿瘤） 不要新增功能 确保拥有良好测试 短小、深思熟虑的步骤 易于测试的代码 项目开始之前的注意点 需求之坑 不要搜集需求-挖掘需求 与用户一起工作，像用户一样思考 注重实效的项目 团队 自动化无处不在 无情的测试（编一点测一点） 温和地超出用户期望]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>programmer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记之代码整洁之道(Clean Code)]]></title>
    <url>%2F2015%2F12%2F02%2Freading-clean-code%2F</url>
    <content type="text"><![CDATA[软件质量，不但依赖于架构及项目管理，而且与代码质量紧密相关。这一点，无论是敏捷开发流派还是传统开发流派，都不得不承认。《代码整洁之道》提出一种观念：代码质量与其整洁度成正比。干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好基础。作为编程领域的佼佼者，《代码整洁之道》作者给出了一系列行之有效的整洁代码操作实践。这些实践在《代码整洁之道》中体现为一条条规则(或称“启示”)，并辅以来自现实项目的正、反两面的范例。只要遵循这些规则，就能编写出干净的代码，从而有效提升代码质量。 《代码整洁之道》阅读对象为一切有志于改善代码质量的程序员及技术经理。书中介绍的规则均来自作者多年的实践经验，涵盖从命名到重构的多个编程方面，虽为一“家”之言，然诚有可资借鉴的价值。 –豆瓣 有意义的命名 方法 短 标识参数丑陋(bool) 抽离try-catch块 注释 不要留下注释后的代码 方法描述中存在无用的循规式注释，需要建立统一的代码注释规范 良好的代码格式 统一团队的代码格式 异常处理 少用null 边界处理 尽量提供的api里不要用map 单元测试 快速（Fast） 独立（Independent） 可重复（Repeatable） 自足验证（Self-validating） 及时（Timely） 三要素：可读性、可读性、可读性 类 短小 单一职责 内聚 边界 map 学习性测试 童子军军规 当你离开一个地方的时候，要让它比你来的时候更加整洁干净 重构 单元测试 code smell 注释 环境 函数 一般性问题 java 名称 测试]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>clean code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github上Fork项目后的常用的操作指南]]></title>
    <url>%2F2015%2F12%2F02%2Fgithub-fork-operation%2F</url>
    <content type="text"><![CDATA[我们经常会从github中fork一些项目，fork完之后会有哪些常用的操作呢？现在把经验分享给大家，希望有利于大家参与到开源的项目来。 提交自己本地修改到自己的项目此步骤即最基本的git修改操作 12345git clone https://github.com/renliufeng/mojocd mojogit add .git commit -m 'modify'git push origin master 自己更新的代码想提交给原作者合并一般在更新完自己的代码之后，如果希望原作者的代码一起支持变更，需要在github上发起PullRequest。在界面上边有个 Pull Requests ，点进去，然后就可以见到你和原作者项目的差异的代码，上面有个 “Create pull request”. 点击后会让你写上本次提交合并“主题”，还有相关提交修改的内容的一些介绍， 这方便原作者理解和了解你的修改，并会考虑是否给你的提交合并到他自己本身的代码。 写完这些信息后， 然后提交过去。 作者的项目就会收到你这个请求了。如果他认为你写的代码没问题，介绍也合理， 就会合并到你的代码到他的主代码中。 更新自己的代码和原作者的项目保持一致经过一段时间， 有可能作者原来的代码变化很大， 你想接着在他最新的代码上修改， 这时你需要合并原作者的最新代码过来， 让你的项目变成最新的。这个需要接着在你的本地操作。假设前提是， 你现在你的代码是克隆下来在本地的。 例如我 Fork 了 sri (Mojo 的作者) 的 Mojo 项目， 我的项目地址是https://github.com/renliufeng/mojo我现在克隆这个在我的本地了。 12git clone https://github.com/renliufeng/mojocd mojo 接着， 我只需要添加 sri 项目的地址,也就是主项目的 remote 地址， 我们加入后， 给代码 fetch 过来， 然后进行 merge 的合并操作。 123git remote add sri https://github.com/kraih/mojogit fetch srigit merge sri/master 这样就能给你的当前本地的项目变成和原作者的主项目一样。 然后你按正常的流程进行修改并提交到你的项目就好了。 12git commit -am '更新到原作者的主分支的进度'git push origin 要接着给修改提交给原作者，请参照第二步。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>fork</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用七牛为Hexo存储图片和CDN加速]]></title>
    <url>%2F2015%2F11%2F27%2Fhexo-qiniu%2F</url>
    <content type="text"><![CDATA[使用七牛为Hexo存储图片Hexo文章中的图片，可以放在本地，然后和静态文件一起发布（部署）到你的空间。我以前就是这么干的，见这里。今天又看Hexo官方文档，有支持七牛的插件，尝试了一下，发现是不可用的，因为插件代码中有一些路径有问题，我已经提交了bug给作者。不过因此我开始试用了七牛，感觉一些功能还是很不错的，而且10GB免费存储，每月10GB免费下载流量…，用做博客图片等资源存储，正合适。 注册和安装七牛工具首先需要申请七牛账号，如果你也需要申请，请访问这个链接（https://portal.qiniu.com/signup?code=3lb1qxh8ee5oy）， 这样我可以获得更多的流量（5GB）。然后登录七牛网站，按照官网说明创建空间。比如我创建的空间是shiqichan，那么我上传的文件，就可以通过这样的URL访问：http://shiqichan.qiniudn.com/myImg.png我上传图片文件，使用了七牛提供的命令行工具，当然你也可以使用七牛提供的web界面上传。使用命令行上传的好处是，批量增量的上传。可在这里下载，有Mac版本。在Mac下的安装办法，解压缩到某个目录下，比如我是存放在/opt/tools/qrsync下了。设置PATH：sudo vim /etc/paths将qrsync路径加进去，这样就可以直接输入命令访问了。Hexo使用七牛图片的步骤我是在blog目录下，创建了个cdn目录，用来存放图片等资源文件。hexo的配置文件，默认日志的url方式是：http://yoursite/year/month/day/your-post-name做了调整，在_config.yml文件中修改：permalink: :title/然后，在cdn目录下，创建日志名称的目录，比如本文的目录名称就是：use-qiniu-store-image-for-hexo在这个目录下放置本文的图片，然后使用qrsync命令同步到七牛。再通过七牛的web界面复制出这个图片的url，比如：http://shiqichan.qiniudn.com/use-qiniu-store-image-for-hexo/qiniu.png最后，就是在日志文件中加入image标签：![](http://shiqichan.qiniudn.com/use-qiniu-store-image-for-hexo/qiniu.png)样式上对图片的处理这样做显示的图片，有个问题，有时候显示图片太大了。查了一下hexo默认样式有关图片的设置（见thems/light/source/css/_partial/article.styl）： 1234img, video max-width 300px height auto border none 这是stylus，用来生成css文件的。对图片宽度做了约束，但没有对图片高度做约束，如果宽度不高而高度很大，就会出现问题。改为： 123456789box-shadow(args…)-webkit-box-shadow args-moz-box-shadow argsbox-shadow argsimg, videomax-width 300pxmax-height 300pxborder nonebox-shadow 2px 2px 3px #aaaaaa]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>七牛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客SEO技巧]]></title>
    <url>%2F2015%2F11%2F27%2Fblog-seo%2F</url>
    <content type="text"><![CDATA[搜索引擎优化(search engine optimization,简称seo)：指遵循搜索引擎的搜索原理，对网站结构、网页文字语言和站点间互动外交略等进行合理规划部署，以改善网站在搜索引擎的搜索表现，进而增加客户发现并访问网站的可能性的这样一个过程. 搜索引擎优化也是一种科学的发展观和方法论，它随着搜索引擎的发展而发展, 同时也促进了搜索引擎的发展。 对博客进行搜索引擎优化也就是博客内容被搜索引擎收录及优先排序，以此增加博客的点击率和曝光度，最终提升博客的综合能力。写博客的人，内容不仅要对用户友好，让大部分人都能看懂，而且也要对搜索引擎友好。 下面提供一些技巧1：博客要经常保持更新，文字始终紧紧围绕关键字，围绕网站主题。2：SEO优化重点以文章内容页优化为主。3：适当给每个页面增加keyword(关键词)、Description(页面描述)、robots(搜索引擎抓取器)等标签。4：在新文章中适当增加一些老文章的链接，文章的内部链接一定要自然。5：新博客可以建立单一关键词策略，以增强网站对搜索引擎的权威性。如卢松松博客建立初期只有一个”网站设计”关键词。6：栏目分类尽量使用目录形式。如：http://lusongsong.com/youhua/而不是http://lusongsong.com/youhua.html7：可以在网页底部加上站点地图sitemap，HTML格式是给用户看的，XML格式是给搜索引擎看的。8：比较重要文章的URL可以使用拼音、英文和分割线等网址结构。9：外部链接建设很重要，新博客推荐使用工具http://tool.lusongsong.com/seo/10：垃圾留言一定要删除，非常影响排名。11：记得给每个博文插图加上和文章内容相关的alt信息，并在图片周围添加相关信息。12：文章中相同的关键词不能过多，如果非要堆砌关键词，可适当使用长尾关键词。13：每篇文章的结尾处可加入“原创文章如转载，请注明出处”“本文首发于XXX网站”等信息，对SEO有一定帮助。14：通过添加TAG标签可以增强主题的相关性和被搜索的概率。15：文章的Title最好以“文章标题-博客名称”形式出现。16：文章标题最好能出现一次关键字。17：关键字最好在第一段或最后一段能够出现。18：不要选择非常热门的关键词。19：不要一次性增加大量连接，更不要一次性删减大量连接。20：坚持!]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置git多SSH-Key共存]]></title>
    <url>%2F2015%2F11%2F25%2Fgit-ssh-key%2F</url>
    <content type="text"><![CDATA[今天整理下以前在配置git过程中的SSH-Key共存的方法 git的入门学习推荐廖雪峰的网站: http://www.liaoxuefeng.com 关于多个SSH Key的共存在使用git过程中，会遇到配置多个ssh-key的共存情况，比如一个连接公司的git，一个用来连接github，或者两个github账户。这里以github和oschina两个ssh-key共存举例。 首先配置github，生成ssh-key1ssh-keygen -t rsa -C “aaa@gmail.com” -f ~/.ssh/github_id_rsa 过程中会要求设置密码，直接回车为空就可以了,此时会生成两个文件githubidrsa和githubidrsa.pub 为了方便区分多个ssh-key，这里我们指定名为githubidrsa，如果不指定会按照生成默认的idrsa 添加SSH agent1ssh-add ~/.ssh/github_id_rsa 由于在默认情况下，SSH agent只会去读取id_rsa，为了使新生成的github_id_rsa能被SSH agent读取，将github_id_rsa添加到SSH agent ssh-key粘贴到github上1vim ~/.ssh/github_id_rsa.pub 可以查看生成的ssh-key，将ssh-key粘贴到github上,并用相同的方法生成oschina的ssh-key，并粘贴到oschina上 ssh共存配置1sudo vim ~/.ssh/config 为了让两个ssh-key共存，在/.ssh下生成一个config文件,通过config文件指定不同的私钥对应的不同git服务器 123456789101112#GitHub(aaa@gmail.com)Host github.comHostName github.comUser gitIdentityFile ~/.ssh/github_id_rsa #OSChina(bbb@gmail.com)Host git.oschina.netHostName git.oschina.netUser gitIdentityFile ~/.ssh/oschina_id_rsa然后可以测试下是否成功连接 检查配置是否起作用12ssh -T github.comssh -T git.oschina.net 过程中会问你是否添加到knownhosts，yes即可，会在.ssh目录下生成一个known_hosts文件 git config 配置需要注意一点的是，git服务一般会根据配置文件的user.name和user.email来获取作者信息(比如上面的github的aaa@gmail.com和oschina的bbb@gmail.com)，如果多账户信息不同的话，需要注意在使用前修改配置。 12345#查看配置信息git config --list#设置全局的name和emailgit config --global user.name "xxx"git config --global user.email "xxx.gmail.com"]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo在github上搭建自己的博客]]></title>
    <url>%2F2015%2F11%2F25%2Fhexo-user-guide%2F</url>
    <content type="text"><![CDATA[最近想写个博客玩一样，就尝试了hexo，使用github.io可以搭建一个自己的博客,把静态文件项目托管到github上,可以写博客,可以使用markdown语法,也可以展示作品.灵活性高.但是有较大的难度. node,git版本变化日新月异,每段时间都会有不同,而这个小不同可能直接导致搭建失败.这里把我搭建的过程记录下来.如果将来搭建失败,可以参考,下载对应的版本尝试. 我使用的版本(mac系统下:) 123node: v0.10.22git: git version 2.3.2 hexo: 3.1 搭建步骤安装好node和git,注册好github账号.注意:用户名一定不能有大写.想下载最新的git可以尝试这个地址: http://msysgit.github.io/ 安装hexo1npm install -g hexo 这里常常安装了一半就卡住装不下去了,推荐安装淘宝镜像: 1npm install -g cnpm --registry=https://registry.npm.taobao.org 创建hexo文件夹自己找一个喜欢的路径,创建hexo文件夹,例如在 ~\hexo下的.cmd窗口切换到对应的目录下,然后执行初始化,等待结束 1hexo init 安装依赖继续执行，安装好所有的依赖 1npm install 完成本地安装继续在项目目录下~\hexo执行一下语句 1234// 生成文件hexo generate // 开启服务器hexo server 然后在打开浏览器 localhost:4000 ,就可以看到,本地已经安装好了. 在github上创建博客仓库 选择New repository跳转的后如下填写:(其中Repository name的格式是 ‘用户名’.github.io),然后点创建仓库。 创建SSH keys，并且配置到github上 具体的请参考ssh的指导文档，很简单的 配置_config.yml文件并发布在 ~\hexo 下,有一个文件叫 _config.yml,打开它,拉到最底下,做如下修改: 1234deploy: type: github //改成github repository: https://github.com/renliufeng/renliufeng.github.io //改成自己的用户名 branch: master 配置完以后还是在~\hexo下执行: 12hexo generatehexo deploy 执行完以后,如果报错 Error: Deployer not found : github,则执行如下命令: 1npm install hexo-deployer-git --save 同时修改 _config.yml : 12deploy: type: git //改成git 然后再执行: 12hexo generatehexo deploy 然后访问: http://renliufeng.github.io/ (用户名改成自己的),就可以看到了. 注意,每次修改本地文件后，需要 hexo generate 才能保存。每次使用命令时，都要在 ~\hexo 目录下 核心命令常用命令1234567$ hexo init #初始化$ hexo new [layout] "postName" #新建文章$ hexo new page "pageName" #新建页面$ hexo generate #生成静态页面至public目录$ hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）$ hexo deploy #将.deploy目录部署到GitHub $ hexo clean //清楚缓存和发布文件 简写命令1234$ hexo n == hexo new$ hexo g == hexo generate$ hexo s == hexo server$ hexo d == hexo deploy 常用复合命令12$ hexo d -g 先生成静态页面，再部署到github$ hexo s -g 先生成静态页面，再本地开启server 问题解决（1） hexo可能更新过了,所以老的hexo可能会报错: 123&#123; [Error: Cannot find module './build/Release/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;&#123; [Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;&#123; [Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125; 解决办法如下,执行: 1npm install hexo --no-optional]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2015%2F11%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
